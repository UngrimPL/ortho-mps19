<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <title>Ortofotomapa – GitHub Pages</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="">
  <style>
    html, body, #map { height: 100%; margin: 0; background:#eaeaea; }
    .legend {
      position:absolute; bottom:12px; left:12px; background:rgba(255,255,255,.92);
      padding:8px 12px; border-radius:8px; font:13px/16px Arial; box-shadow:0 2px 8px rgba(0,0,0,.2);
    }
    .toast {
      position:absolute; top:12px; right:12px; background:rgba(0,0,0,.75); color:#fff;
      padding:8px 12px; border-radius:8px; font:13px/16px Arial; max-width:360px;
    }
  </style>
</head>
<body>
<div id="map"></div>
<div class="legend">
  <b>Ortofotomapa</b><br/>Auto-detekcja: poziomów i formatu kafelków
</div>
<div id="toast" class="toast" style="display:none"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
<script src="https://unpkg.com/leaflet-hash"></script>
<script>
(async function(){
  const toast = (msg) => {
    const el = document.getElementById('toast');
    el.textContent = msg;
    el.style.display = 'block';
    setTimeout(() => el.style.display = 'none', 6000);
  };

  // Domyślny środek — podmień, jeśli chcesz
  let center = L.latLng(52.0032, 19.2011);

  // Spróbuj wczytać metadata.json (Agisoft zwykle go dodaje)
  try {
    const r = await fetch('./tiles/metadata.json');
    if (r.ok) {
      const meta = await r.json();
      if (meta && meta.bounds) {
        const [xmin, ymin, xmax, ymax] = meta.bounds;
        center = L.latLng((ymin + ymax)/2, (xmin + xmax)/2);
      }
    }
  } catch(e){}

  // Inicjalizacja mapy (zoom ustawimy po detekcji)
  const map = L.map('map', { zoomControl: true });
  new L.Hash(map);
  L.control.scale({ metric:true, imperial:false }).addTo(map);

  // TMS = true (Agisoft TMS)
  const TMS = true;
  const TILE = 256;

  // Pobierz zoom z URL, jeśli jest (#z/lat/lon)
  const hashZoomMatch = location.hash.match(/#(\d+)/);
  const urlZoom = hashZoomMatch ? parseInt(hashZoomMatch[1], 10) : null;

  // Funkcja obliczająca indeks kafla dla lat/lng/zoom
  function xyzForLatLng(latlng, z) {
    // WebMercator projekcja w Leaflet
    const projected = map.options.crs.project(latlng); // punkt w metrach
    const scale = 256 * Math.pow(2, z) / (2 * Math.PI * 6378137);
    const x = Math.floor((projected.x + Math.PI * 6378137) * scale);
    const yMerc = (projected.y + Math.PI * 6378137) * scale; // w "XYZ"
    let y = Math.floor(yMerc);
    if (TMS) {
      const maxIndex = Math.pow(2, z) - 1;
      y = maxIndex - y; // konwersja XYZ -> TMS
    }
    return { x, y };
  }

  // Sprawdź, czy istnieje kafelek dla danego z/ext
  async function testTile(z, ext) {
    const { x, y } = xyzForLatLng(center, z);
    const url = `./tiles/${z}/${x}/${y}.${ext}`;
    try {
      const resp = await fetch(url, { method: 'HEAD', cache: 'no-store' });
      return resp.ok;
    } catch(e){
      return false;
    }
  }

  // Znajdź najniższy dostępny zoom i rozszerzenie (jpg -> png)
  async function detect() {
    const exts = ['jpg', 'png'];
    for (const ext of exts) {
      for (let z = 15; z <= 22; z++) {
        const ok = await testTile(z, ext);
        if (ok) return { minZoom: z, ext };
      }
    }
    return null;
  }

  const detected = await detect();
  if (!detected) {
    map.setView(center, urlZoom || 17);
    toast('Nie znaleziono kafelków. Sprawdź, czy folder to dokładnie /tiles/ oraz czy nazwy mają .jpg lub .png dla poziomów 15–22.');
    return;
  }

  const { minZoom, ext } = detected;

  // Jeśli w URL był mniejszy zoom niż dostępny — podbijemy
  const startZoom = Math.max(minZoom, urlZoom || minZoom);

  // Dodaj warstwę tileLayer
  const layer = L.tileLayer(`./tiles/{z}/{x}/{y}.${ext}`, {
    tms: TMS,
    minZoom: minZoom,
    maxZoom: 22,
    attribution: '&copy; Orto (Agisoft Metashape)'
  }).addTo(map);

  map.setView(center, startZoom);
  toast(`Wykryto: format .${ext}, minZoom ${minZoom}, TMS: TAK`);
})();
</script>
</body>
</html>
